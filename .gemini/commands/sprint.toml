description = "Sprint execution for GitHub issues"

prompt = """
Takes pre-selected GitHub issue numbers, builds a wave-based execution plan, and implements them sequentially on separate branches.

Works in any venture console repo. The prior step selects which issues go into the sprint; this command handles execution.

## Arguments

Parse {{args}}:
1. Split on whitespace and commas
2. Strip `#` prefix from tokens
3. Extract `--dry-run` flag if present
4. Extract `--parallel N` if present (ignored for Gemini - execution is sequential, but the value is displayed for reference)
5. Remaining tokens are issue numbers (positive integers)

If no issue numbers after parsing, display usage and stop:
```
Usage: /sprint <issue numbers> [--dry-run]
Examples:
  /sprint 42 45 51
  /sprint 42, 45 --dry-run
```

Store: ISSUE_NUMBERS (array), DRY_RUN (bool).

## Step 1: Detect Repo Context

```
basename $(pwd)
git remote get-url origin
```

- VENTURE_CODE: basename minus `-console` suffix
- REPO: extract `org/repo` from git remote URL
- REPO_ROOT: `git rev-parse --show-toplevel`
- VERIFY_COMMAND: read CLAUDE.md and extract verify command (typically `npm run verify`)

If not in a git repo, stop: "Not in a recognized repo. Run /sprint from a venture console directory."

## Step 2: Fetch and Analyze Issues

For each issue number, fetch: `gh issue view {N} --repo {REPO} --json number,title,body,labels,state`

Extract from labels: Priority (prio:*), QA grade (qa-grade:*), Component (component:*), Type (type:*), Status (status:*).
Extract from body: AC count (checkbox items), body word count.

Validation:
- If any issue not found, stop: "Issue #{N} not found in {REPO}. Aborting."
- If any issue closed, stop: "Issue #{N} is closed. Remove it and re-run."
- If any issue lacks `status:ready`, warn (don't block).

Display issue summary table.

## Step 3: Build Wave Plan

**Extract dependencies**: Scan issue bodies for: `depends on #N`, `blocked by #N`, `after #N`, `requires #N`. Only track in-sprint dependencies.

**Schedule waves**: Sort available issues by priority (P0 first), then issue number. Group into waves based on dependencies.

**Advisory warnings**: If two issues in the same wave share a component label, warn about potential file conflicts.

Display wave plan. If DRY_RUN: stop with "Dry run complete. Re-run without --dry-run to execute."

## Step 4: Approval

Ask: "Execute Wave 1? ({N} issues will be processed sequentially)"
Options: "Execute" / "Abort"

## Step 5: Execute Wave 1 Issues (Sequential)

For each issue in Wave 1, execute sequentially on a separate branch:

### Per-Issue Workflow

1. **Create branch**: `git checkout -b {issue-number}-{slugified-title} main`
   - Slug: title lowercased, spaces to hyphens, non-alphanumeric removed, max 50 chars
   - If branch exists, ask user: reuse or create with `-2` suffix

2. **Read CLAUDE.md** for project conventions and build commands.

3. **Explore** relevant code. Read nearby files to understand patterns.

4. **Implement** the change. Make minimal, focused changes. Do not refactor unrelated code.

5. **Verify**: Run `{VERIFY_COMMAND}`. Fix failures and re-run. If cannot pass after 3 attempts, STOP and report failure. Do NOT open a PR with failing verification.

6. **Commit**: Stage specific changed files (not git add -A). Use conventional commit message referencing the issue number.

7. **Push**: `git push -u origin {branch-name}`

8. **Open PR**: Use `gh pr create` with:
   - `--repo {REPO} --base main --head {branch-name}`
   - Title: `{type}: {description}`
   - Body with Summary, Changes, Test Plan, and `Closes #{NUMBER}`

9. **Return to main**: `git checkout main`

10. **Record result**: PR URL or FAILED with reason.

### For each successful PR:
Update issue label: remove `status:ready`, add `status:review` via `gh issue edit`.

### For each failure:
Ask: "Issue #{N} failed: {reason}. Retry or skip?"
- Retry: delete branch, recreate from main, try once more. Second failure is final.
- Skip: mark incomplete, continue.

## Step 6: Report and Cleanup

Display wave results:
```
Wave 1 Complete: {succeeded}/{total} issues

| #   | Title              | Status  | PR    |
| --- | ------------------ | ------- | ----- |
| 45  | Fix balance calc   | SUCCESS | #67   |
| 42  | Add expense filter | FAILED  | -     |
```

If remaining waves exist: "Remaining waves: {count}. Next: merge the PRs above, then run: /sprint {remaining issue numbers}"

Branches are preserved (they back the open PRs).

## Notes

- Single-wave execution per run. User merges PRs, then re-runs for next wave.
- Branches from main. PRs are independently reviewable.
- Label updates happen in the orchestrator, not during coding.
- One retry max per failed issue. Second failure is final.
- Sequential execution in Gemini (no parallel worktrees).
"""
